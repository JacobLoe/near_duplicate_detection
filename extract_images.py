import os
import cv2
import numpy as np
from tqdm import tqdm
import xml.etree.ElementTree as ET
#################################################################
def read_shotdetect_xml(path):
    tree = ET.parse(path)
    root=tree.getroot().findall('content')
    info={}
    timestamps=[]
    for child in root[0].iter():
        if child.tag == 'shot':
            items=child.items()
            timestamps.append((int(items[4][1]),int(items[4][1])+int(items[2][1])-1))
    return timestamps #in ms
#############################################################################################
#read video file frame by frame, beginning and ending with a timestamp
def read_video(video_path,start_ms,end_ms):
    vid = cv2.VideoCapture(video_path)
    frames=[]
    fps = vid.get(cv2.CAP_PROP_FPS)

    start_frame=int((start_ms/1000.0)*fps)
    end_frame=int((end_ms/1000.0)*fps)

    middle_frame=start_frame+round((end_frame-start_frame)/2)
    frame_size=(224, 224)
    frame_timestamps=[]
    vid_length=0
#    with tqdm(total=end_frame-start_frame+1) as pbar: #init the progressbar,with max length of the given segment
#        vid.set(cv2.CAP_PROP_POS_FRAMES,start_frame)
#        while(vid.isOpened()):
#            ret, frame = vid.read()
#            if (vid_length+start_frame)==end_frame:
#                pbar.update(1)
#                break

#            frame=cv2.resize(frame,frame_size)
#            frames.append(np.array(frame,dtype='float32'))
#            frame_timestamps.append(vid_length+start_frame)
#            pbar.update(1) #update the progressbar
#            vid_length+=1 #increase the vid_length counter
############################################################
    with tqdm(total=3) as pbar: #init the progressbar,with max length of the given segment
            vid.set(cv2.CAP_PROP_POS_FRAMES,middle_frame-1)
            ret, frame = vid.read()
            frame=cv2.resize(frame,frame_size)
            frames.append(np.array(frame,dtype='float32'))
            frame_timestamps.append(middle_frame-1)
            pbar.update(1)

            vid.set(cv2.CAP_PROP_POS_FRAMES,middle_frame)
            ret, frame = vid.read()
            frame=cv2.resize(frame,frame_size)
            frames.append(np.array(frame,dtype='float32'))
            frame_timestamps.append(middle_frame)
            pbar.update(1)

            vid.set(cv2.CAP_PROP_POS_FRAMES,middle_frame+1)
            ret, frame = vid.read()
            frame=cv2.resize(frame,frame_size)
            frames.append(np.array(frame,dtype='float32'))
            frame_timestamps.append(middle_frame+1)
            pbar.update(1)
    vid.release()
    cv2.destroyAllWindows()
    return frames,frame_timestamps
###########################################################################################
#save a frame to disk given a timestamp, the timestamp is expected to be the 'index' of a frame
def save_frame_to_disk(video_path,frame_path,frame_timestamp):
    vid = cv2.VideoCapture(video_path)
    vid.set(cv2.CAP_PROP_POS_FRAMES,frame_timestamp)
    ret, frame = vid.read()
    name = frame_path+str(frame_timestamp)+'.png'
    cv2.imwrite(name,frame)
#########################################################################################################
if __name__ == "__main__":
   videos_path='videos/'
   features_path='features_videos/'

   for video_dir in os.listdir(videos_path):
       # check if the directories corresponding video_directory exist
       #
       if not os.path.isdir(features_path+video_dir):
          os.mkdir(features_path+video_dir)
       
       #get the shot timestamps generated by shotdetect
       shot_timestamps = read_shotdetect_xml(features_path+video_dir+'/result.xml')
       
       #extract frames for the shots and their timestamp,
       # save them in the features dir
       for video in os.listdir(videos_path+video_dir):
           # check whether a dir exist to save the frames in 
           if not os.path.isdir(features_path+video_dir+'/shots/'):
              os.mkdir(features_path+video_dir+'/shots/')

           #
           for start_ms,end_ms in shot_timestamps:
               shot_path = features_path+video_dir+'/shots/'+str((start_ms,end_ms))+'/'
               frames,frame_timestamps = read_video(videos_path+video_dir+'/'+video,start_ms,end_ms)
               #print(np.shape(frames))

               #save the frames to disk
               #the frames for one shot are saved in a folder corresponding to their shot
               if not os.path.isdir(shot_path):
                  os.mkdir(shot_path)
               for i,frame in enumerate(frames):
                   save_frame_to_disk(videos_path+video_dir+'/'+video,shot_path,frame_timestamps[i])
               #break
              
       #save the frames to disk
#       break



